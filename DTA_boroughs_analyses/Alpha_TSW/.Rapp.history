mat = matrix(nrow=1, ncol=2); mat[1,1] = min(values); mat[1,2] = max(values); rast = raster(matrix(mat))#
plot(rast, legend.only=T, add=T, col=colorRampPalette(brewer.pal(9,"YlGn"))(101), legend.width=0.5,#
	 legend.shrink=0.3, smallplot=c(0.10,0.113,0.15,0.50), legend.args=list(text="", cex=0.8, line=0.5, col="gray30"),#
	 axis.args=list(cex.axis=0.7, lwd=0, lwd.tick=0.2, tck=-0.5, line=0, mgp=c(0,0.4,0)), alpha=1)#
add.scale.bar(length=NULL, ask=F, lwd=0.5 , lcol ="gray30", cex=0.7)#
title1 = "Importance of"; mtext(title1, side=3, line=-16.3, at=0.08, cex=0.75, font=1, col="gray30")#
title2 = "grasslands as"; mtext(title2, side=3, line=-17.1, at=0.08, cex=0.75, font=1, col="gray30")#
title3 = "a SDM predictor"; mtext(title3, side=3, line=-17.9, at=0.08, cex=0.75, font=1, col="gray30")
plot(tree3, show.tip.label=T, edge.width=0.5, cex=0.6, align.tip.label=3, col="gray30")
mat = matrix(nrow=1, ncol=2); mat[1,1] = min(values); mat[1,2] = max(values); rast = raster(matrix(mat))#
plot(rast, legend.only=T, add=T, col=colorRampPalette(brewer.pal(9,"YlGn"))(101), legend.width=0.5,#
	 legend.shrink=0.3, smallplot=c(0.10,0.113,0.15,0.50), legend.args=list(text="", cex=0.8, line=0.5, col="gray30"),#
	 axis.args=list(cex.axis=0.7, lwd=0, lwd.tick=0.2, tck=-0.5, line=0, mgp=c(0,0.4,0)), alpha=1)#
add.scale.bar(length=NULL, ask=F, lwd=0.5 , lcol ="gray30", cex=0.7)#
title1 = "Importance of"; mtext(title1, side=3, line=-16.2, at=0.08, cex=0.75, font=1, col="gray30")#
title2 = "grasslands as"; mtext(title2, side=3, line=-17.0, at=0.08, cex=0.75, font=1, col="gray30")#
title3 = "a SDM predictor"; mtext(title3, side=3, line=-17.8, at=0.08, cex=0.75, font=1, col="gray30")
values = matrix(nrow=dim(traits)[1], ncol=1)#
values[,1] = traits[tree2$tip.label,"croplands"]#
colourScale = colorRampPalette(brewer.pal(9,"YlGn"))(101)#
# colourScale = colorRampPalette(c("white","lemonchiffon2"),bias=1)(101)#
cols = colourScale[(((values-min(values))/(max(values)-min(values)))*100)+1]#
tree3 = tree2; tree3$tip.label = gsub("B_", "    B. ", tree3$tip.label)#
dev.new(width=7, height=7.5); par(oma=c(0,0,0,0), mar=c(0.8,1.2,0.5,2.2), lwd=0.2)#
plot(tree3, show.tip.label=T, edge.width=0.5, cex=0.6, align.tip.label=3, col="gray30")#
for (i in 1:dim(tree3$edge)[1])#
	{#
		if (!tree3$edge[i,2]%in%tree3$edge[,1])#
			{#
				nodelabels(node=tree3$edge[i,2], pch=16, cex=1.2, col=cols[tree3$edge[i,2]])#
				nodelabels(node=tree3$edge[i,2], pch=1, cex=1.2, col="gray30", lwd=0.5)#
			}#
	}#
mat = matrix(nrow=1, ncol=2); mat[1,1] = min(values); mat[1,2] = max(values); rast = raster(matrix(mat))#
plot(rast, legend.only=T, add=T, col=colorRampPalette(brewer.pal(9,"YlGn"))(101), legend.width=0.5,#
	 legend.shrink=0.3, smallplot=c(0.11,0.123,0.15,0.50), legend.args=list(text="", cex=0.8, line=0.5, col="gray30"),#
	 axis.args=list(cex.axis=0.7, lwd=0, lwd.tick=0.2, tck=-0.5, line=0, mgp=c(0,0.4,0)), alpha=1)#
add.scale.bar(length=NULL, ask=F, lwd=0.5 , lcol ="gray30", cex=0.7)#
title1 = "Importance of"; mtext(title1, side=3, line=-16.2, at=0.09, cex=0.75, font=1, col="gray30")#
title2 = "grasslands as"; mtext(title2, side=3, line=-17.0, at=0.09, cex=0.75, font=1, col="gray30")#
title3 = "a SDM predictor"; mtext(title3, side=3, line=-17.8, at=0.09, cex=0.75, font=1, col="gray30")
values = matrix(nrow=dim(traits)[1], ncol=1)#
values[,1] = traits[tree2$tip.label,"croplands"]#
colourScale = colorRampPalette(brewer.pal(9,"YlGn"))(101)#
# colourScale = colorRampPalette(c("white","lemonchiffon2"),bias=1)(101)#
cols = colourScale[(((values-min(values))/(max(values)-min(values)))*100)+1]#
tree3 = tree2; tree3$tip.label = gsub("B_", "    B. ", tree3$tip.label)#
dev.new(width=7, height=7.5); par(oma=c(0,0,0,0), mar=c(0.8,1.2,0.5,2.2), lwd=0.2)#
plot(tree3, show.tip.label=T, edge.width=0.5, cex=0.6, align.tip.label=3, col="gray30")#
for (i in 1:dim(tree3$edge)[1])#
	{#
		if (!tree3$edge[i,2]%in%tree3$edge[,1])#
			{#
				nodelabels(node=tree3$edge[i,2], pch=16, cex=1.2, col=cols[tree3$edge[i,2]])#
				nodelabels(node=tree3$edge[i,2], pch=1, cex=1.2, col="gray30", lwd=0.5)#
			}#
	}#
mat = matrix(nrow=1, ncol=2); mat[1,1] = min(values); mat[1,2] = max(values); rast = raster(matrix(mat))#
plot(rast, legend.only=T, add=T, col=colorRampPalette(brewer.pal(9,"YlGn"))(101), legend.width=0.5, alpha=1,#
	 legend.shrink=0.3, smallplot=c(0.11,0.123,0.15,0.50), legend.args=list(text="", cex=0.8, line=0.5, col="gray30"),#
	 axis.args=list(cex.axis=0.7, lwd=0, lwd.tick=0.2, tck=-0.5, line=0, mgp=c(0,0.4,0), at=seq(0,35), labels=seq(0,0.35,0.1)))#
add.scale.bar(length=NULL, ask=F, lwd=0.5 , lcol ="gray30", cex=0.7)#
title1 = "Importance of"; mtext(title1, side=3, line=-16.2, at=0.09, cex=0.75, font=1, col="gray30")#
title2 = "grasslands as"; mtext(title2, side=3, line=-17.0, at=0.09, cex=0.75, font=1, col="gray30")#
title3 = "a SDM predictor"; mtext(title3, side=3, line=-17.8, at=0.09, cex=0.75, font=1, col="gray30")
plot(rast, legend.only=T, add=T, col=colorRampPalette(brewer.pal(9,"YlGn"))(101), legend.width=0.5,#
	 legend.shrink=0.3, smallplot=c(0.11,0.123,0.15,0.50), legend.args=list(text="", cex=0.8, line=0.5, col="gray30"),#
	 axis.args=list(cex.axis=0.7, lwd=0, lwd.tick=0.2, tck=-0.5, line=0, mgp=c(0,0.4,0), at=seq(0,35), labels=seq(0,0.35,0.1)), alpha=1)
plot(rast, legend.only=T, add=T, col=colorRampPalette(brewer.pal(9,"YlGn"))(101), legend.width=0.5,#
	 legend.shrink=0.3, smallplot=c(0.11,0.123,0.15,0.50), legend.args=list(text="", cex=0.8, line=0.5, col="gray30"),#
	 axis.args=list(cex.axis=0.7, lwd=0, lwd.tick=0.2, tck=-0.5, line=0, mgp=c(0,0.4,0), at=seq(0,35,1), labels=seq(0,0.35,0.5)), alpha=1)
plot(rast, legend.only=T, add=T, col=colorRampPalette(brewer.pal(9,"YlGn"))(101), legend.width=0.5,#
	 legend.shrink=0.3, smallplot=c(0.11,0.123,0.15,0.50), legend.args=list(text="", cex=0.8, line=0.5, col="gray30"),#
	 axis.args=list(cex.axis=0.7, lwd=0, lwd.tick=0.2, tck=-0.5, line=0, mgp=c(0,0.4,0), at=seq(0,35,5), labels=seq(0,0.35,0.5)), alpha=1)
seq(0,35,5)
values = matrix(nrow=dim(traits)[1], ncol=1)#
values[,1] = traits[tree2$tip.label,"croplands"]#
colourScale = colorRampPalette(brewer.pal(9,"YlGn"))(101)#
# colourScale = colorRampPalette(c("white","lemonchiffon2"),bias=1)(101)#
cols = colourScale[(((values-min(values))/(max(values)-min(values)))*100)+1]#
tree3 = tree2; tree3$tip.label = gsub("B_", "    B. ", tree3$tip.label)#
dev.new(width=7, height=7.5); par(oma=c(0,0,0,0), mar=c(0.8,1.2,0.5,2.2), lwd=0.2)#
plot(tree3, show.tip.label=T, edge.width=0.5, cex=0.6, align.tip.label=3, col="gray30")#
for (i in 1:dim(tree3$edge)[1])#
	{#
		if (!tree3$edge[i,2]%in%tree3$edge[,1])#
			{#
				nodelabels(node=tree3$edge[i,2], pch=16, cex=1.2, col=cols[tree3$edge[i,2]])#
				nodelabels(node=tree3$edge[i,2], pch=1, cex=1.2, col="gray30", lwd=0.5)#
			}#
	}#
mat = matrix(nrow=1, ncol=2); mat[1,1] = min(values); mat[1,2] = max(values); rast = raster(matrix(mat))#
plot(rast, legend.only=T, add=T, col=colorRampPalette(brewer.pal(9,"YlGn"))(101), legend.width=0.5,#
	 legend.shrink=0.3, smallplot=c(0.11,0.123,0.15,0.50), legend.args=list(text="", cex=0.8, line=0.5, col="gray30"),#
	 axis.args=list(cex.axis=0.7, lwd=0, lwd.tick=0.2, tck=-0.5, line=0, mgp=c(0,0.4,0), at=seq(0,35,5), labels=seq(0,0.35,0.05)), alpha=1)#
add.scale.bar(length=NULL, ask=F, lwd=0.5 , lcol ="gray30", cex=0.7)#
title1 = "Importance of"; mtext(title1, side=3, line=-16.2, at=0.09, cex=0.75, font=1, col="gray30")#
title2 = "grasslands as"; mtext(title2, side=3, line=-17.0, at=0.09, cex=0.75, font=1, col="gray30")#
title3 = "a SDM predictor"; mtext(title3, side=3, line=-17.8, at=0.09, cex=0.75, font=1, col="gray30")
values = matrix(nrow=dim(traits)[1], ncol=1)#
values[,1] = traits[tree2$tip.label,"croplands"]#
colourScale = colorRampPalette(brewer.pal(9,"YlGn"))(101)#
# colourScale = colorRampPalette(c("white","lemonchiffon2"),bias=1)(101)#
cols = colourScale[(((values-min(values))/(max(values)-min(values)))*100)+1]#
tree3 = tree2; tree3$tip.label = gsub("B_", "    B. ", tree3$tip.label)#
dev.new(width=7, height=7.5); par(oma=c(0,0,0,0), mar=c(0.8,1.2,0.5,2.2), lwd=0.2)#
plot(tree3, show.tip.label=T, edge.width=0.5, cex=0.6, align.tip.label=3, col="gray30")#
for (i in 1:dim(tree3$edge)[1])#
	{#
		if (!tree3$edge[i,2]%in%tree3$edge[,1])#
			{#
				nodelabels(node=tree3$edge[i,2], pch=16, cex=1.2, col=cols[tree3$edge[i,2]])#
				nodelabels(node=tree3$edge[i,2], pch=1, cex=1.2, col="gray30", lwd=0.5)#
			}#
	}#
mat = matrix(nrow=1, ncol=2); mat[1,1] = min(values); mat[1,2] = max(values); rast = raster(matrix(mat))#
plot(rast, legend.only=T, add=T, col=colorRampPalette(brewer.pal(9,"YlGn"))(101), legend.width=0.5, alpha=1,#
	 legend.shrink=0.3, smallplot=c(0.11,0.123,0.15,0.50), legend.args=list(text="", cex=0.8, line=0.5, col="gray30"),#
	 axis.args=list(cex.axis=0.7, lwd=0, lwd.tick=0.2, tck=-0.5, line=0, mgp=c(0,0.4,0), at=seq(0,35,5),#
	 labels=c("0.00","0.05","0.10","0.15","0.20","0.25","0.30","0.35")))#
add.scale.bar(length=NULL, ask=F, lwd=0.5 , lcol ="gray30", cex=0.7)#
title1 = "Importance of"; mtext(title1, side=3, line=-16.2, at=0.09, cex=0.75, font=1, col="gray30")#
title2 = "grasslands as"; mtext(title2, side=3, line=-17.0, at=0.09, cex=0.75, font=1, col="gray30")#
title3 = "a SDM predictor"; mtext(title3, side=3, line=-17.8, at=0.09, cex=0.75, font=1, col="gray30")
values = matrix(nrow=dim(traits)[1], ncol=1)#
values[,1] = traits[tree2$tip.label,"croplands"]#
colourScale = colorRampPalette(brewer.pal(9,"YlGn"))(101)#
# colourScale = colorRampPalette(c("white","lemonchiffon2"),bias=1)(101)#
cols = colourScale[(((values-min(values))/(max(values)-min(values)))*100)+1]#
tree3 = tree2; tree3$tip.label = gsub("B_", "    B. ", tree3$tip.label)#
dev.new(width=7, height=7.5); par(oma=c(0,0,0,0), mar=c(0.8,1.2,0.5,2.2), lwd=0.2)#
plot(tree3, show.tip.label=T, edge.width=0.5, cex=0.6, align.tip.label=3, col="gray30")#
for (i in 1:dim(tree3$edge)[1])#
	{#
		if (!tree3$edge[i,2]%in%tree3$edge[,1])#
			{#
				nodelabels(node=tree3$edge[i,2], pch=16, cex=1.2, col=cols[tree3$edge[i,2]])#
				nodelabels(node=tree3$edge[i,2], pch=1, cex=1.2, col="gray30", lwd=0.5)#
			}#
	}#
mat = matrix(nrow=1, ncol=2); mat[1,1] = min(values); mat[1,2] = max(values); rast = raster(matrix(mat))#
plot(rast, legend.only=T, add=T, col=colorRampPalette(brewer.pal(9,"YlGn"))(101), legend.width=0.5, alpha=1,#
	 legend.shrink=0.3, smallplot=c(0.11,0.123,0.15,0.50), legend.args=list(text="", cex=0.8, line=0.5, col="gray30"),#
	 axis.args=list(cex.axis=0.7, lwd=0, lwd.tick=0.2, tck=-0.5, line=0, mgp=c(0,0.4,0), at=seq(0,35,5),#
	 labels=c("0.00","0.05","0.10","0.15","0.20","0.25","0.30","0.35")))#
add.scale.bar(length=NULL, ask=F, lwd=0.5 , lcol ="gray30", cex=0.7)#
title1 = "Importance of"; mtext(title1, side=3, line=-16.1, at=0.10, cex=0.75, font=1, col="gray30")#
title2 = "grasslands as"; mtext(title2, side=3, line=-16.9, at=0.10, cex=0.75, font=1, col="gray30")#
title3 = "a SDM predictor"; mtext(title3, side=3, line=-17.7, at=0.10, cex=0.75, font=1, col="gray30")
l = length(tree3$tip.label)+1
l
l1 = length(tree3$tip.label)+1
l1
l1 = length(tree3$tip.label)+1; l2 = (2*l1)-1#
internalNodes = seq(l1, l2, 1)
internalNodes
length(tree3$tip.label)
(2*l1)-1
dev.new(width=7, height=7.5); par(oma=c(0,0,0,0), mar=c(0.8,1.2,0.5,2.2), lwd=0.2)#
plot(tree3, show.tip.label=T, show.node.label=T, edge.width=0.5, cex=0.6, align.tip.label=3, col="gray30")#
for (i in 1:dim(tree3$edge)[1])#
	{#
		if (!tree3$edge[i,2]%in%tree3$edge[,1])#
			{#
				nodelabels(node=tree3$edge[i,2], pch=16, cex=1.2, col=cols[tree3$edge[i,2]])#
				nodelabels(node=tree3$edge[i,2], pch=1, cex=1.2, col="gray30", lwd=0.5)#
			}#
	}#
mat = matrix(nrow=1, ncol=2); mat[1,1] = min(values); mat[1,2] = max(values); rast = raster(matrix(mat))#
plot(rast, legend.only=T, add=T, col=colorRampPalette(brewer.pal(9,"YlGn"))(101), legend.width=0.5, alpha=1,#
	 legend.shrink=0.3, smallplot=c(0.11,0.123,0.15,0.50), legend.args=list(text="", cex=0.8, line=0.5, col="gray30"),#
	 axis.args=list(cex.axis=0.7, lwd=0, lwd.tick=0.2, tck=-0.5, line=0, mgp=c(0,0.4,0), at=seq(0,35,5),#
	 labels=c("0.00","0.05","0.10","0.15","0.20","0.25","0.30","0.35")))#
add.scale.bar(length=NULL, ask=F, lwd=0.5 , lcol ="gray30", cex=0.7)#
title1 = "Importance of"; mtext(title1, side=3, line=-16.1, at=0.10, cex=0.75, font=1, col="gray30")#
title2 = "grasslands as"; mtext(title2, side=3, line=-16.9, at=0.10, cex=0.75, font=1, col="gray30")#
title3 = "a SDM predictor"; mtext(title3, side=3, line=-17.7, at=0.10, cex=0.75, font=1, col="gray30")
node.labels(tree3)
str(tree3)
plot(tree3, show.tip.label=T, show.node.label=T, edge.width=0.5, cex=0.6, align.tip.label=3, col="gray30")#
l1 = length(tree3$tip.label)+1; l2 = (2*length(tree3$tip.label))-1#
nodelabels(tree3$node.label, node=l1:l2, adj = c(-0.2, -0.2), cex=0.3)
nodelabels(tree3$node.label, node=l1:l2, adj = c(-0.5), cex=0.3)
values = matrix(nrow=dim(traits)[1], ncol=1)#
values[,1] = traits[tree2$tip.label,"croplands"]#
colourScale = colorRampPalette(brewer.pal(9,"YlGn"))(101)#
# colourScale = colorRampPalette(c("white","lemonchiffon2"),bias=1)(101)#
cols = colourScale[(((values-min(values))/(max(values)-min(values)))*100)+1]#
tree3 = tree2; tree3$tip.label = gsub("B_", "    B. ", tree3$tip.label)#
dev.new(width=7, height=7.5); par(oma=c(0,0,0,0), mar=c(0.8,1.2,0.5,2.2), lwd=0.2)#
plot(tree3, show.tip.label=T, show.node.label=T, edge.width=0.5, cex=0.6, align.tip.label=3, col="gray30")#
l1 = length(tree3$tip.label)+1; l2 = (2*length(tree3$tip.label))-1#
nodelabels(tree3$node.label, node=l1:l2, adj = c(-0.5), cex=0.3)
plot(tree3, show.tip.label=T, show.node.label=T, edge.width=0.5, cex=0.6, align.tip.label=3, col="gray30")#
l1 = length(tree3$tip.label)+1; l2 = (2*length(tree3$tip.label))-1#
nodelabels(tree3$node.label, node=l1:l2, cex=0.3)
tree3$node.label
l1:l2
length(tree3$tip.label)+1
l1 = length(tree3$tip.label)+1; l2 = (2*length(tree3$tip.label))-2
plot(tree3, show.tip.label=T, show.node.label=T, edge.width=0.5, cex=0.6, align.tip.label=3, col="gray30")#
l1 = length(tree3$tip.label)+1; l2 = (2*length(tree3$tip.label))-2#
nodelabels(tree3$node.label, node=l1:l2, cex=0.3)
values = matrix(nrow=dim(traits)[1], ncol=1)#
values[,1] = traits[tree2$tip.label,"croplands"]#
colourScale = colorRampPalette(brewer.pal(9,"YlGn"))(101)#
# colourScale = colorRampPalette(c("white","lemonchiffon2"),bias=1)(101)#
cols = colourScale[(((values-min(values))/(max(values)-min(values)))*100)+1]#
tree3 = tree2; tree3$tip.label = gsub("B_", "    B. ", tree3$tip.label)#
dev.new(width=7, height=7.5); par(oma=c(0,0,0,0), mar=c(0.8,1.2,0.5,2.2), lwd=0.2)#
plot(tree3, show.tip.label=T, show.node.label=T, edge.width=0.5, cex=0.6, align.tip.label=3, col="gray30")#
l1 = length(tree3$tip.label)+1; l2 = (2*length(tree3$tip.label))-2#
for (i in 1:dim(tree3$edge)[1])#
	{#
		if (!tree3$edge[i,2]%in%tree3$edge[,1])#
			{#
				nodelabels(node=tree3$edge[i,2], pch=16, cex=1.2, col=cols[tree3$edge[i,2]])#
				nodelabels(node=tree3$edge[i,2], pch=1, cex=1.2, col="gray30", lwd=0.5)#
			}#
	}#
mat = matrix(nrow=1, ncol=2); mat[1,1] = min(values); mat[1,2] = max(values); rast = raster(matrix(mat))#
plot(rast, legend.only=T, add=T, col=colorRampPalette(brewer.pal(9,"YlGn"))(101), legend.width=0.5, alpha=1,#
	 legend.shrink=0.3, smallplot=c(0.11,0.123,0.15,0.50), legend.args=list(text="", cex=0.8, line=0.5, col="gray30"),#
	 axis.args=list(cex.axis=0.7, lwd=0, lwd.tick=0.2, tck=-0.5, line=0, mgp=c(0,0.4,0), at=seq(0,35,5),#
	 labels=c("0.00","0.05","0.10","0.15","0.20","0.25","0.30","0.35")))#
add.scale.bar(length=NULL, ask=F, lwd=0.5 , lcol ="gray30", cex=0.7)#
title1 = "Importance of"; mtext(title1, side=3, line=-16.1, at=0.10, cex=0.75, font=1, col="gray30")#
title2 = "grasslands as"; mtext(title2, side=3, line=-16.9, at=0.10, cex=0.75, font=1, col="gray30")#
title3 = "a SDM predictor"; mtext(title3, side=3, line=-17.7, at=0.10, cex=0.75, font=1, col="gray30")
print(K_pValues)
library(raster); library(fields); library(RColorBrewer); library(dismo); library(rJava); library(gbm); library(pgirmess)#
options(java.parameters="-Xmx15000m"); source("decreaseResolution.r"); source("landCoverRasters.r")#
#
datasetsDirectory = "Bombus_observations_2"#
resolution = "16"; # resolution = "04"#
e_1 = extent(-19, 88, 19, 82); e_2 = extent(-15, 84, 23, 78)#
subsampling_adjacent_cells = TRUE; background_cell = TRUE#
background_mask = FALSE; human_pop_density_bias = FALSE#
cols = rev(colorRampPalette(brewer.pal(11,"RdYlBu"))(121)[11:101])#
plotWidth = 7.0; plotHeight = 6.2#
datasets = list.files(datasetsDirectory); # datasets = datasets[40]#
datasets = gsub(".csv","",datasets[which(grepl(".csv",datasets))])
importances = read.csv("MaxEnt_importances.csv", header=T)
head(importances)
row.names(importances)
importances = importances[-which(row.names(importances)),]
write.csv(importances, "MaxEnt_importances.csv", quote=F)
importances = read.csv("MaxEnt_importances.csv", header=T)
importances = importances[-which(row.names(importances)),]
row.names(importances)
importances = importances[-which(row.names(importances)=="B_wurflenii"),]
importances
pca = dudi.pca(importances, scannf=F, nf=19); lis = pca$li[,1:2]; cos = pca$co
??dudi.pca
library(ade4)
importances = read.csv("MaxEnt_importances.csv", header=T)#
importances = importances[-which(row.names(importances)=="B_wurflenii"),]#
pca = dudi.pca(importances, scannf=F, nf=19); lis = pca$li[,1:2]; cos = pca$co
dev.new(width=7, height=6); par(mar=c(3,3,1.5,1.5))#
plot(lis, col="gray30", cex=0.7, pch=16, ann=F, axes=F, xlim=c(-6.3,4.3))#
# s.corcircle(2*cos,xax=1,yax=2,box=F,sub="",csub=1,clabel=1.5,possub="topleft",grid=T,cgrid=1,full=T,add.plot=T)#
text(lis[,1], lis[,2], labels=gsub("B_","",row.names(lis)), cex=0.6, col="gray30", pos=4, offset=0.25)#
axis(side=1, lwd.tick=0.2, cex.axis=0.6, lwd=0.2, tck=-0.010, col.axis="gray30", mgp=c(0,0,0), at=seq(-8,5,1))#
axis(side=2, lwd.tick=0.2, cex.axis=0.6, lwd=0.2, tck=-0.010, col.axis="gray30", mgp=c(0,0.3,0), at=seq(-9,5,1))#
title(xlab="PCA axis 1", cex.lab=0.7, mgp=c(1.0,0,0), col.lab="gray30")#
title(ylab="PCA axis 2", cex.lab=0.7, mgp=c(1.3,0,0), col.lab="gray30")
importances
importances[c("brodmannicus","campestris"),]
importances[c("B_brodmannicus","B_campestris"),]
datasets
h=8
if (background_cell == TRUE)#
					{#
						null_raster[!(1:length(null_raster[]))%in%background_cells] = NA#
						human_pop_density_log[!(1:length(human_pop_density_log[]))%in%background_cells] = NA#
					}#
				if ((background_mask == TRUE)&(human_pop_density_bias == TRUE))#
					{#
						background_r = mask(human_pop_density_log, background_masks[[h]]); stack = mask(rasters_stacks, background_masks[[h]])#
					}#
				if ((background_mask == TRUE)&(human_pop_density_bias == FALSE))#
					{#
						background_r = mask(null_raster, background_masks[[h]]); stack = mask(rasters_stacks, background_masks[[h]])#
					}#
				if ((background_mask == FALSE)&(human_pop_density_bias == FALSE))#
					{#
						background_r = null_raster; stack = rasters_stacks#
					}#
				observations = observations_list[[h]]#
				pseudo_absences = xyFromCell(background_r, sample(which(!is.na(values(background_r))),10000,prob=values(background_r)[!is.na(values(background_r))]))#
				presences = cbind(observations, rep(1,dim(observations)[1]))#
				absences = cbind(pseudo_absences, rep(0,dim(pseudo_absences)[1]))#
				colnames(absences)[1] = "longitude"; colnames(absences)[2] = "latitude"#
				colnames(absences)[3] = "response"; colnames(presences)[3] = "response"
library(raster); library(fields); library(RColorBrewer); library(dismo); library(rJava); library(gbm); library(pgirmess)#
options(java.parameters="-Xmx15000m"); source("decreaseResolution.r"); source("landCoverRasters.r")#
#
datasetsDirectory = "Bombus_observations_2"#
resolution = "16"; # resolution = "04"#
e_1 = extent(-19, 88, 19, 82); e_2 = extent(-15, 84, 23, 78)#
subsampling_adjacent_cells = TRUE; background_cell = TRUE#
background_mask = FALSE; human_pop_density_bias = FALSE#
cols = rev(colorRampPalette(brewer.pal(11,"RdYlBu"))(121)[11:101])#
plotWidth = 7.0; plotHeight = 6.2#
datasets = list.files(datasetsDirectory); # datasets = datasets[40]#
datasets = gsub(".csv","",datasets[which(grepl(".csv",datasets))])#
#
# 1. Preparing the environmental rasters#
#
	# 1.1. Cropping the WorldClim 2.0 raster files (source: http://worldclim.org/bioclim)#
#
bioclimatic_variables = as.character(read.csv("Bioclimatic_variables.csv",header=T)[,"short_name"])#
files = list.files("WorldClim_2.0_rasters"); rasters_1 = list(); c = 0#
for (i in 1:length(files))#
	{#
		if ((grepl(".tif",files[i]) == TRUE)&(!file.exists(paste0("WorldClim_2.0_rasters/",gsub(".tif",paste0("_",resolution,".asc"),gsub("_2.5m","",files[i]))))))#
			{#
				rast = crop(raster(paste0("WorldClim_2.0_rasters/",files[i])),e_1)#
				if (resolution == "16") rast = decreaseResolution(rast, 4)#
				writeRaster(rast, paste0("WorldClim_2.0_rasters/",gsub(".tif",paste0("_",resolution,".asc"),gsub("_2.5m","",files[i]))))#
				c = c+1; rast = raster(paste0("WorldClim_2.0_rasters/",files[i])); id = unlist(strsplit(files[i],"_"))[length(unlist(strsplit(files[i],"_")))]#
				names(rast) = bioclimatic_variables[as.numeric(gsub(".tif","",id))]; rasters_1[[c]] = rast#
			}	else		{#
				if (grepl(paste0("_",resolution,".asc"),files[i]) == TRUE)#
					{#
						c = c+1; rast = raster(paste0("WorldClim_2.0_rasters/",files[i])); id = unlist(strsplit(files[i],"_"))[length(unlist(strsplit(files[i],"_")))-1]#
						names(rast) = bioclimatic_variables[as.numeric(gsub(".asc","",id))]; crs(rast) = CRS("+proj=longlat +datum=WGS84"); rasters_1[[c]] = rast#
					}#
			}#
	}#
#
	# 1.2. Preparing the land cover variables (source: https://lpdaac.usgs.gov/dataset_discovery/modis/modis_products_table/mcd12q1)#
#
rasters_2 = list(); land_cover_variables = c("barren_vegetation","closed_shrubland","croplands","deciduous_broadleaf_forest",#
								"deciduous_needleleaf_forest", "evergreen_broadleaf_forest","evergreen_needleleaf_forest","grasslands",#
								"mixed_forests","open_shrublands","savannas","snow_ice","urban_areas","wetlands","woody_savannas")#
if (!file.exists(paste0("Land_cover_rasters/CL_",land_cover_variables[1],"_",resolution,".asc")))#
	{#
		cover_land = crop(raster("IGBP_land_cover.tif"), e_1)#
		if (resolution == "04") landCoverRasters(rast=cover_land, R=5)#
		if (resolution == "16") landCoverRasters(rast=cover_land, R=20)#
	}#
for (i in 1:length(land_cover_variables))#
	{#
		rast = raster(paste0("Land_cover_rasters/CL_",land_cover_variables[i],"_",resolution,".asc"))#
		names(rast) = land_cover_variables[i]; rasters_2[[i]] = rast#
		# print(c(i, length(unique(extract(rast,observations)))))#
	}#
#
	# 1.3. Preparing the Natural Earth background raster (visualisation only)#
#
background = crop(raster("Background_raster.tif"), e_1); background[background[]==106] = NA; r = background#
cols_background = colorRampPalette(c("grey","white"),bias=1)(max(r[],na.rm=T)-min(r[],na.rm=T))[1:(max(r[],na.rm=T)-min(r[],na.rm=T))]#
#
# 2. Variables selection based on pairwise correlations#
#
observations_list = list(); N_tot_1 = 0; N_tot_2 = 0#
for (h in 1:length(datasets))#
	{#
		observations = read.csv(paste0(datasetsDirectory,"/",datasets[h],".csv"), header=T)#
		N_tot_1 = N_tot_1 + dim(observations)[1]#
		observations = unique(observations[,c("longitude","latitude")])#
		N_tot_2 = N_tot_2 + dim(observations)[1]#
		observations = observations[!is.na(extract(rasters_1[[1]], observations)),]#
		observations = observations[!is.na(extract(rasters_2[[1]], observations)),]#
		observations_list[[h]] = observations; cat(datasets[h]); cat("\n")#
		if (h == 1)#
			{#
				xmin = min(observations[,1]); xmax = max(observations[,1])#
				ymin = min(observations[,2]); ymax = max(observations[,2])#
			}	else		{#
				if (xmin > min(observations[,1])) xmin = min(observations[,1])#
				if (xmax < max(observations[,1])) xmax = max(observations[,1])#
				if (ymin > min(observations[,2])) ymin = min(observations[,2])#
				if (ymax < max(observations[,2])) ymax = max(observations[,2])#
			}#
	}#
#
for (h in 1:length(datasets)) # to print the pairs of predictors with a Pearson's r >= 0.7, and the non-variable predictors#
	{#
		observations = observations_list[[h]]#
		for (i in 1:length(rasters_1))#
			{#
				rast = crop(rasters_1[[i]], e_2); res(rast) = res(rasters_1[[1]])#
				crs(rast) = CRS("+proj=longlat +datum=WGS84"); names(rast) = names(rasters_1[[i]]); rasters_1[[i]] = rast#
			}#
		extractions = matrix(nrow=dim(observations)[1], ncol=length(rasters_1)); colnames(extractions) = bioclimatic_variables#
		correlations = matrix(nrow=length(rasters_1), ncol=length(rasters_1)); row.names(correlations) = bioclimatic_variables #
		for (i in 1:length(rasters_1)) extractions[,names(rasters_1[[i]])] = extract(rasters_1[[i]], observations)#
		for (i in 1:length(rasters_1))#
			{#
				for (j in 1:i)#
					{#
						correlations[i,j] = cor(extractions[,i],extractions[,j]); correlations[j,i] = correlations[i,j]#
					}#
			}#
		for (i in 2:length(rasters_1))#
			{#
				for (j in 1:(i-1))#
					{#
						if ((!is.na(correlations[i,j]))&(abs(correlations[i,j]) >= 0.7))#
							{#
								# cat(paste0("	    r >= 0.7 - BIO ",bioclimatic_variables[i]," - BIO ",bioclimatic_variables[j])); cat("\n")#
								cat(paste0("	    r >= 0.7 - BIO ",i," - BIO ",j)); cat("\n")#
							}#
					}#
			}#
		for (i in 1:length(rasters_2))#
			{#
				rast = crop(rasters_2[[i]], e_2); res(rast) = res(rasters_1[[1]]); extent(rast) = extent(rasters_1[[1]])#
				crs(rast) = CRS("+proj=longlat +datum=WGS84"); names(rast) = names(rasters_2[[i]]); rasters_2[[i]] = rast#
			}#
		extractions = matrix(nrow=dim(observations)[1], ncol=length(rasters_2)); colnames(extractions) = land_cover_variables#
		correlations = matrix(nrow=length(rasters_2), ncol=length(rasters_2)); row.names(correlations) = land_cover_variables #
		for (i in 1:length(rasters_2)) extractions[,names(rasters_2[[i]])] = extract(rasters_2[[i]], observations)#
		for (i in 1:length(rasters_2))#
			{#
				for (j in 1:i)#
					{#
						correlations[i,j] = cor(extractions[,i],extractions[,j]); correlations[j,i] = correlations[i,j]#
					}#
			}#
		for (i in 2:length(rasters_2))#
			{#
				for (j in 1:(i-1))#
					{#
						if ((!is.na(correlations[i,j]))&(abs(correlations[i,j]) >= 0.7))#
							{#
								cat(paste0("    r >= 0.7 - ",land_cover_variables[i]," - ",land_cover_variables[j])); cat("\n")#
							}#
					}#
			}#
		for (i in 1:length(rasters_2))#
			{#
				if (length(unique(extractions[,i])) == 1)#
					{#
						cat(paste0("    no variation in ",land_cover_variables[i],", variable number ",i)); cat("\n")#
					}#
			}#
	}#
rasters1_to_select = c(1,4,12,15); rasters2_to_select = 1:length(rasters_2); rasters_stacks = list()#
for (h in 1:length(datasets))#
	{#
		if (h == 1)#
			{#
				rasters = list()#
				for (i in rasters1_to_select)#
					{#
						rast = crop(rasters_1[[i]], e_2); res(rast) = res(rasters_1[[1]])#
						crs(rast) = CRS("+proj=longlat +datum=WGS84"); names(rast) = names(rasters_1[[i]])#
						rasters[[length(rasters)+1]] = rast#
					}#
				for (i in rasters2_to_select)#
					{#
						rast = crop(rasters_2[[i]], e_2); res(rast) = res(rasters_1[[1]]); extent(rast) = extent(rasters_1[[1]])#
						crs(rast) = CRS("+proj=longlat +datum=WGS84"); names(rast) = names(rasters_2[[i]])#
						rasters[[length(rasters)+1]] = rast#
					}#
				# rast = crop(human_pop_density, e_2); res(rast) = res(rasters_1[[1]]); extent(rast) = extent(rasters_1[[1]])#
				# crs(rast) = CRS("+proj=longlat +datum=WGS84"); rasters[[length(rasters)+1]] = rast # to add human pop. density#
				for (i in 1:length(rasters1_to_select))#
					{#
						rast1 = rasters[[i]]; rast2 = rasters_2[[1]]; rast1[is.na(rast2[])] = NA; rasters[[i]] = rast1#
					}#
				variables = rep(NA, length(rasters))#
				for (i in 1:length(rasters)) variables[i] = names(rasters[[i]])#
				rasters_stacks = stack(rasters)#
			}#
		observations = observations_list[[h]]#
		extractions = matrix(nrow=dim(observations)[1], ncol=length(rasters)); colnames(extractions) = variables#
		correlations = matrix(nrow=length(rasters), ncol=length(rasters)); row.names(correlations) = variables #
		for (i in 1:length(rasters)) extractions[,names(rasters[[i]])] = extract(rasters[[i]], observations)#
		for (i in 1:length(rasters))#
			{#
				for (j in 1:i)#
					{#
						correlations[i,j] = cor(extractions[,i],extractions[,j]); correlations[j,i] = correlations[i,j]#
					}#
			}#
		for (i in 2:length(rasters)) # second sanity check...#
			{#
				for (j in 1:(i-1))#
					{#
						if ((!is.na(correlations[i,j]))&(abs(correlations[i,j]) >= 0.7))#
							{#
								cat(paste("    r >= 0.7 - variable ",i," - variable ",j)); cat("\n")#
							}#
					}#
			}#
	}#
#
# 3. Preparing the human population density and null rasters
if (resolution == "04") human_pop_density = decreaseResolution(crop(raster("Human_pop_density.tif"), e_1), R=5)#
if (resolution == "16") human_pop_density = decreaseResolution(crop(raster("Human_pop_density.tif"), e_1), R=20)#
names(human_pop_density) = "human_pop_density"; writeRaster(human_pop_density, "Human_pop_density.asc", overwrite=T)#
human_pop_density[human_pop_density[]<0] = 0#
human_pop_density_log = human_pop_density; human_pop_density[] = log(human_pop_density[]+1)#
rast = crop(human_pop_density, e_2); res(rast) = res(rasters_1[[1]]); extent(rast) = extent(rasters_1[[1]])#
crs(rast) = CRS("+proj=longlat +datum=WGS84"); human_pop_density = rast#
rast = crop(human_pop_density_log, e_2); res(rast) = res(rasters_1[[1]]); extent(rast) = extent(rasters_1[[1]])#
crs(rast) = CRS("+proj=longlat +datum=WGS84"); human_pop_density_log = rast#
null_raster = human_pop_density; null_raster[!is.na(null_raster[])] = 1
# system("R CMD javareconf"); # rJava_0.9-10.tar.gz doesn't work...#
# install.packages("rJava_0.9-9.tar.gz", repos=NULL, type="source")#
# install.packages("dismo_1.1-4.tar.gz", repos=NULL, type="source")#
#
dyn.load("/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/server/libjvm.dylib") # MacBook Simon#
# dyn.load("/Library/Java/JavaVirtualMachines/jdk1.8.0_102.jdk/Contents/Home/jre/lib/server/libjvm.dylib") # MacPro Simon#
library(raster); library(fields); library(RColorBrewer); library(dismo); library(rJava); library(gbm); library(geosphere); library(rgdal); library(pgirmess)#
options(java.parameters="-Xmx15000m"); source("decreaseResolution.r"); source("landCoverRasters.r")#
#
datasetsDirectory = "Bombus_observations_2"#
resolution = "16"; # resolution = "04"#
e_1 = extent(-19, 88, 19, 82); e_2 = extent(-15, 84, 23, 78)#
subsampling_adjacent_cells = TRUE; background_cell = TRUE#
background_mask = FALSE; human_pop_density_bias = FALSE#
cols = rev(colorRampPalette(brewer.pal(11,"RdYlBu"))(121)[11:101])#
plotWidth = 7.0; plotHeight = 6.2#
datasets = list.files(datasetsDirectory); # datasets = datasets[40]#
datasets = gsub(".csv","",datasets[which(grepl(".csv",datasets))])#
#
# 1. Preparing the environmental rasters#
#
	# 1.1. Cropping the WorldClim 2.0 raster files (source: http://worldclim.org/bioclim)#
#
bioclimatic_variables = as.character(read.csv("Bioclimatic_variables.csv",header=T)[,"short_name"])#
files = list.files("WorldClim_2.0_rasters"); rasters_1 = list(); c = 0#
for (i in 1:length(files))#
	{#
		if ((grepl(".tif",files[i]) == TRUE)&(!file.exists(paste0("WorldClim_2.0_rasters/",gsub(".tif",paste0("_",resolution,".asc"),gsub("_2.5m","",files[i]))))))#
			{#
				rast = crop(raster(paste0("WorldClim_2.0_rasters/",files[i])),e_1)#
				if (resolution == "16") rast = decreaseResolution(rast, 4)#
				writeRaster(rast, paste0("WorldClim_2.0_rasters/",gsub(".tif",paste0("_",resolution,".asc"),gsub("_2.5m","",files[i]))))#
				c = c+1; rast = raster(paste0("WorldClim_2.0_rasters/",files[i])); id = unlist(strsplit(files[i],"_"))[length(unlist(strsplit(files[i],"_")))]#
				names(rast) = bioclimatic_variables[as.numeric(gsub(".tif","",id))]; rasters_1[[c]] = rast#
			}	else		{#
				if (grepl(paste0("_",resolution,".asc"),files[i]) == TRUE)#
					{#
						c = c+1; rast = raster(paste0("WorldClim_2.0_rasters/",files[i])); id = unlist(strsplit(files[i],"_"))[length(unlist(strsplit(files[i],"_")))-1]#
						names(rast) = bioclimatic_variables[as.numeric(gsub(".asc","",id))]; crs(rast) = CRS("+proj=longlat +datum=WGS84"); rasters_1[[c]] = rast#
					}#
			}#
	}#
#
	# 1.2. Preparing the land cover variables (source: https://lpdaac.usgs.gov/dataset_discovery/modis/modis_products_table/mcd12q1)#
#
rasters_2 = list(); land_cover_variables = c("barren_vegetation","closed_shrubland","croplands","deciduous_broadleaf_forest",#
								"deciduous_needleleaf_forest", "evergreen_broadleaf_forest","evergreen_needleleaf_forest","grasslands",#
								"mixed_forests","open_shrublands","savannas","snow_ice","urban_areas","wetlands","woody_savannas")#
if (!file.exists(paste0("Land_cover_rasters/CL_",land_cover_variables[1],"_",resolution,".asc")))#
	{#
		cover_land = crop(raster("IGBP_land_cover.tif"), e_1)#
		if (resolution == "04") landCoverRasters(rast=cover_land, R=5)#
		if (resolution == "16") landCoverRasters(rast=cover_land, R=20)#
	}#
for (i in 1:length(land_cover_variables))#
	{#
		rast = raster(paste0("Land_cover_rasters/CL_",land_cover_variables[i],"_",resolution,".asc"))#
		names(rast) = land_cover_variables[i]; rasters_2[[i]] = rast#
		# print(c(i, length(unique(extract(rast,observations)))))#
	}#
#
	# 1.3. Preparing the Natural Earth background raster (visualisation only)#
#
background = crop(raster("Natural_Earth_GIS_files/Gray_background.tif"), e_1); background[background[]==106] = NA; r = background#
cols_background = colorRampPalette(c("grey","white"),bias=1)(max(r[],na.rm=T)-min(r[],na.rm=T))[1:(max(r[],na.rm=T)-min(r[],na.rm=T))]#
#
# 2. Variables selection based on pairwise correlations#
#
observations_list = list(); N_tot_1 = 0; N_tot_2 = 0#
species_information = read.csv("species_information.csv", header=T)#
# landPolygons = crop(shapefile("World_land_polygons/World_land_polygons.shp"), e_1)#
# writeOGR(landPolygons, dsn="World_land_polygons", layer="Europe_land_polygons", driver="ESRI Shapefile")#
landPolygons_light = rgeos::gSimplify(shapefile("World_land_polygons/Europe_land_polygons.shp"), 0.1)#
plot(landPolygons_light, lwd=0.2, col="gray90", border=NA)
h=3
observations = read.csv(paste0(datasetsDirectory,"/",datasets[h],".csv"), header=T)#
		N_tot_1 = N_tot_1 + dim(observations)[1]#
		observations = unique(observations[,c("longitude","latitude")])#
		N_tot_2 = N_tot_2 + dim(observations)[1]#
		observations = observations[!is.na(extract(rasters_1[[1]], observations)),]#
		observations = observations[!is.na(extract(rasters_2[[1]], observations)),]#
		observations_list[[h]] = observations; cat(datasets[h]); cat("\n")#
		if (h == 1)#
			{#
				xmin = min(observations[,1]); xmax = max(observations[,1])#
				ymin = min(observations[,2]); ymax = max(observations[,2])#
			}	else		{#
				if (xmin > min(observations[,1])) xmin = min(observations[,1])#
				if (xmax < max(observations[,1])) xmax = max(observations[,1])#
				if (ymin > min(observations[,2])) ymin = min(observations[,2])#
				if (ymax < max(observations[,2])) ymax = max(observations[,2])#
			}
hull = chull(observations); hull = c(hull,hull[1])#
		p = Polygon(observations[hull,]); ps = Polygons(list(p),1)#
		sps = SpatialPolygons(list(ps)); crs(sps) = crs(landPolygons)#
		range = intersect(sps, landPolygons_light); plot(range, add=T, col="red")
hull = chull(observations); hull = c(hull,hull[1])#
		p = Polygon(observations[hull,]); ps = Polygons(list(p),1)#
		sps = SpatialPolygons(list(ps)); crs(sps) = crs(landPolygons_light)#
		range = intersect(sps, landPolygons_light); plot(range, add=T, col="red")
observations_list = list(); N_tot_1 = 0; N_tot_2 = 0#
species_information = read.csv("species_information.csv", header=T)#
# landPolygons = crop(shapefile("World_land_polygons/World_land_polygons.shp"), e_1)#
# writeOGR(landPolygons, dsn="World_land_polygons", layer="Europe_land_polygons", driver="ESRI Shapefile")#
landPolygons_light = rgeos::gSimplify(shapefile("World_land_polygons/Europe_land_polygons.shp"), 0.1)#
plot(landPolygons_light, lwd=0.2, col="gray90", border=NA)#
for (h in 1:length(datasets))#
	{#
		observations = read.csv(paste0(datasetsDirectory,"/",datasets[h],".csv"), header=T)#
		N_tot_1 = N_tot_1 + dim(observations)[1]#
		observations = unique(observations[,c("longitude","latitude")])#
		N_tot_2 = N_tot_2 + dim(observations)[1]#
		observations = observations[!is.na(extract(rasters_1[[1]], observations)),]#
		observations = observations[!is.na(extract(rasters_2[[1]], observations)),]#
		observations_list[[h]] = observations; cat(datasets[h]); cat("\n")#
		if (h == 1)#
			{#
				xmin = min(observations[,1]); xmax = max(observations[,1])#
				ymin = min(observations[,2]); ymax = max(observations[,2])#
			}	else		{#
				if (xmin > min(observations[,1])) xmin = min(observations[,1])#
				if (xmax < max(observations[,1])) xmax = max(observations[,1])#
				if (ymin > min(observations[,2])) ymin = min(observations[,2])#
				if (ymax < max(observations[,2])) ymax = max(observations[,2])#
			}#
		hull = chull(observations); hull = c(hull,hull[1])#
		p = Polygon(observations[hull,]); ps = Polygons(list(p),1)#
		sps = SpatialPolygons(list(ps)); crs(sps) = crs(landPolygons_light)#
		range = intersect(sps, landPolygons_light); plot(range, add=T, col="red")#
		index = which(species_information[,"species"]==datasets[h])#
		species_information[index,"area_km2"] = areaPolygon(range)/1000000#
	}#
write.csv(species_information, "species_information.csv", quote=F, row.names=F)
h
observations = read.csv(paste0(datasetsDirectory,"/",datasets[h],".csv"), header=T)#
		N_tot_1 = N_tot_1 + dim(observations)[1]#
		observations = unique(observations[,c("longitude","latitude")])#
		N_tot_2 = N_tot_2 + dim(observations)[1]#
		observations = observations[!is.na(extract(rasters_1[[1]], observations)),]#
		observations = observations[!is.na(extract(rasters_2[[1]], observations)),]#
		observations_list[[h]] = observations; cat(datasets[h]); cat("\n")
if (h == 1)#
			{#
				xmin = min(observations[,1]); xmax = max(observations[,1])#
				ymin = min(observations[,2]); ymax = max(observations[,2])#
			}	else		{#
				if (xmin > min(observations[,1])) xmin = min(observations[,1])#
				if (xmax < max(observations[,1])) xmax = max(observations[,1])#
				if (ymin > min(observations[,2])) ymin = min(observations[,2])#
				if (ymax < max(observations[,2])) ymax = max(observations[,2])#
			}
hull = chull(observations); hull = c(hull,hull[1])
p = Polygon(observations[hull,]); ps = Polygons(list(p),1)
sps = SpatialPolygons(list(ps)); crs(sps) = crs(landPolygons_light)
range = intersect(sps, landPolygons_light); plot(range, add=T, col="red")
index = which(species_information[,"species"]==datasets[h])
index
species_information[index,"area_km2"] = areaPolygon(range)/1000000
index
species_information[index,"area_km2"]
areaPolygon(range)/1000000
range
range = intersect(sps, landPolygons_light); plot(range, add=T, col="green3")
hist(areaPolygon(range)/1000000)
max(areaPolygon(range)/1000000)
plot(landPolygons_light, lwd=0.2, col="gray90", border=NA)#
for (h in 1:length(datasets))#
	{#
		observations = read.csv(paste0(datasetsDirectory,"/",datasets[h],".csv"), header=T)#
		N_tot_1 = N_tot_1 + dim(observations)[1]#
		observations = unique(observations[,c("longitude","latitude")])#
		N_tot_2 = N_tot_2 + dim(observations)[1]#
		observations = observations[!is.na(extract(rasters_1[[1]], observations)),]#
		observations = observations[!is.na(extract(rasters_2[[1]], observations)),]#
		observations_list[[h]] = observations; cat(datasets[h]); cat("\n")#
		if (h == 1)#
			{#
				xmin = min(observations[,1]); xmax = max(observations[,1])#
				ymin = min(observations[,2]); ymax = max(observations[,2])#
			}	else		{#
				if (xmin > min(observations[,1])) xmin = min(observations[,1])#
				if (xmax < max(observations[,1])) xmax = max(observations[,1])#
				if (ymin > min(observations[,2])) ymin = min(observations[,2])#
				if (ymax < max(observations[,2])) ymax = max(observations[,2])#
			}#
		hull = chull(observations); hull = c(hull,hull[1])#
		p = Polygon(observations[hull,]); ps = Polygons(list(p),1)#
		sps = SpatialPolygons(list(ps)); crs(sps) = crs(landPolygons_light)#
		range = intersect(sps, landPolygons_light); plot(range, add=T, col="green3")#
		index = which(species_information[,"species"]==datasets[h])#
		species_information[index,"area_km2"] = sum(areaPolygon(range)/1000000)#
	}#
write.csv(species_information, "species_information.csv", quote=F, row.names=F)
datasets
h=47
plot(landPolygons_light, lwd=0.2, col="gray90", border=NA)
observations = read.csv(paste0(datasetsDirectory,"/",datasets[h],".csv"), header=T)#
		N_tot_1 = N_tot_1 + dim(observations)[1]#
		observations = unique(observations[,c("longitude","latitude")])#
		N_tot_2 = N_tot_2 + dim(observations)[1]#
		observations = observations[!is.na(extract(rasters_1[[1]], observations)),]#
		observations = observations[!is.na(extract(rasters_2[[1]], observations)),]#
		observations_list[[h]] = observations; cat(datasets[h]); cat("\n")#
		if (h == 1)#
			{#
				xmin = min(observations[,1]); xmax = max(observations[,1])#
				ymin = min(observations[,2]); ymax = max(observations[,2])#
			}	else		{#
				if (xmin > min(observations[,1])) xmin = min(observations[,1])#
				if (xmax < max(observations[,1])) xmax = max(observations[,1])#
				if (ymin > min(observations[,2])) ymin = min(observations[,2])#
				if (ymax < max(observations[,2])) ymax = max(observations[,2])#
			}#
		hull = chull(observations); hull = c(hull,hull[1])#
		p = Polygon(observations[hull,]); ps = Polygons(list(p),1)#
		sps = SpatialPolygons(list(ps)); crs(sps) = crs(landPolygons_light)#
		range = intersect(sps, landPolygons_light); plot(range, add=T, col="green3")
index = which(species_information[,"species"]==datasets[h])
index
observations = read.csv(paste0(datasetsDirectory,"/",datasets[h],".csv"), header=T)#
		N_tot_1 = N_tot_1 + dim(observations)[1]#
		observations = unique(observations[,c("longitude","latitude")])#
		N_tot_2 = N_tot_2 + dim(observations)[1]#
		observations = observations[!is.na(extract(rasters_1[[1]], observations)),]#
		observations = observations[!is.na(extract(rasters_2[[1]], observations)),]#
		observations_list[[h]] = observations; cat(datasets[h]); cat("\n")#
		if (h == 1)#
			{#
				xmin = min(observations[,1]); xmax = max(observations[,1])#
				ymin = min(observations[,2]); ymax = max(observations[,2])#
			}	else		{#
				if (xmin > min(observations[,1])) xmin = min(observations[,1])#
				if (xmax < max(observations[,1])) xmax = max(observations[,1])#
				if (ymin > min(observations[,2])) ymin = min(observations[,2])#
				if (ymax < max(observations[,2])) ymax = max(observations[,2])#
			}#
		hull = chull(observations); hull = c(hull,hull[1])#
		p = Polygon(observations[hull,]); ps = Polygons(list(p),1)#
		sps = SpatialPolygons(list(ps)); crs(sps) = crs(landPolygons_light)#
		range = intersect(sps, landPolygons_light); plot(range, add=T, col="green3")#
		index = which(species_information[,"species"]==datasets[h])#
		species_information[index,"area_km2"] = sum(areaPolygon(range)/1000000)
write.csv(species_information, "species_information.csv", quote=F, row.names=F)
species_information = read.csv("species_information.csv", header=T)
observations = read.csv(paste0(datasetsDirectory,"/",datasets[h],".csv"), header=T)#
		N_tot_1 = N_tot_1 + dim(observations)[1]#
		observations = unique(observations[,c("longitude","latitude")])#
		N_tot_2 = N_tot_2 + dim(observations)[1]#
		observations = observations[!is.na(extract(rasters_1[[1]], observations)),]#
		observations = observations[!is.na(extract(rasters_2[[1]], observations)),]#
		observations_list[[h]] = observations; cat(datasets[h]); cat("\n")#
		if (h == 1)#
			{#
				xmin = min(observations[,1]); xmax = max(observations[,1])#
				ymin = min(observations[,2]); ymax = max(observations[,2])#
			}	else		{#
				if (xmin > min(observations[,1])) xmin = min(observations[,1])#
				if (xmax < max(observations[,1])) xmax = max(observations[,1])#
				if (ymin > min(observations[,2])) ymin = min(observations[,2])#
				if (ymax < max(observations[,2])) ymax = max(observations[,2])#
			}#
		hull = chull(observations); hull = c(hull,hull[1])#
		p = Polygon(observations[hull,]); ps = Polygons(list(p),1)#
		sps = SpatialPolygons(list(ps)); crs(sps) = crs(landPolygons_light)#
		range = intersect(sps, landPolygons_light); plot(range, add=T, col="green3")#
		index = which(species_information[,"species"]==datasets[h])#
		species_information[index,"area_km2"] = sum(areaPolygon(range)/1000000)
write.csv(species_information, "species_information.csv", quote=F, row.names=F)
species_information = read.csv("species_information.csv", header=T)
observations = read.csv(paste0(datasetsDirectory,"/",datasets[h],".csv"), header=T)#
		N_tot_1 = N_tot_1 + dim(observations)[1]#
		observations = unique(observations[,c("longitude","latitude")])#
		N_tot_2 = N_tot_2 + dim(observations)[1]#
		observations = observations[!is.na(extract(rasters_1[[1]], observations)),]#
		observations = observations[!is.na(extract(rasters_2[[1]], observations)),]#
		observations_list[[h]] = observations; cat(datasets[h]); cat("\n")#
		if (h == 1)#
			{#
				xmin = min(observations[,1]); xmax = max(observations[,1])#
				ymin = min(observations[,2]); ymax = max(observations[,2])#
			}	else		{#
				if (xmin > min(observations[,1])) xmin = min(observations[,1])#
				if (xmax < max(observations[,1])) xmax = max(observations[,1])#
				if (ymin > min(observations[,2])) ymin = min(observations[,2])#
				if (ymax < max(observations[,2])) ymax = max(observations[,2])#
			}#
		hull = chull(observations); hull = c(hull,hull[1])#
		p = Polygon(observations[hull,]); ps = Polygons(list(p),1)#
		sps = SpatialPolygons(list(ps)); crs(sps) = crs(landPolygons_light)#
		range = intersect(sps, landPolygons_light); plot(range, add=T, col="green3")#
		index = which(species_information[,"species"]==datasets[h])#
		species_information[index,"area_km2"] = sum(areaPolygon(range)/1000000)
species_information = read.csv("species_information.csv", header=T)
observations = read.csv(paste0(datasetsDirectory,"/",datasets[h],".csv"), header=T)#
		N_tot_1 = N_tot_1 + dim(observations)[1]#
		observations = unique(observations[,c("longitude","latitude")])#
		N_tot_2 = N_tot_2 + dim(observations)[1]#
		observations = observations[!is.na(extract(rasters_1[[1]], observations)),]#
		observations = observations[!is.na(extract(rasters_2[[1]], observations)),]#
		observations_list[[h]] = observations; cat(datasets[h]); cat("\n")#
		if (h == 1)#
			{#
				xmin = min(observations[,1]); xmax = max(observations[,1])#
				ymin = min(observations[,2]); ymax = max(observations[,2])#
			}	else		{#
				if (xmin > min(observations[,1])) xmin = min(observations[,1])#
				if (xmax < max(observations[,1])) xmax = max(observations[,1])#
				if (ymin > min(observations[,2])) ymin = min(observations[,2])#
				if (ymax < max(observations[,2])) ymax = max(observations[,2])#
			}#
		hull = chull(observations); hull = c(hull,hull[1])#
		p = Polygon(observations[hull,]); ps = Polygons(list(p),1)#
		sps = SpatialPolygons(list(ps)); crs(sps) = crs(landPolygons_light)#
		range = intersect(sps, landPolygons_light); plot(range, add=T, col="green3")#
		index = which(species_information[,"species"]==datasets[h])
index
species_information[index,"area_km2"] = sum(areaPolygon(range)/1000000)
species_information[index,"area_km2"]
write.csv(species_information, "species_information.csv", quote=F, row.names=F)
observations_list = list(); N_tot_1 = 0; N_tot_2 = 0#
species_information = read.csv("species_information.csv", header=T)#
# landPolygons = crop(shapefile("World_land_polygons/World_land_polygons.shp"), e_1)#
# writeOGR(landPolygons, dsn="World_land_polygons", layer="Europe_land_polygons", driver="ESRI Shapefile")#
landPolygons_light = rgeos::gSimplify(shapefile("World_land_polygons/Europe_land_polygons.shp"), 0.1)#
plot(landPolygons_light, lwd=0.2, col="gray90", border=NA)#
for (h in 1:length(datasets))#
	{#
		observations = read.csv(paste0(datasetsDirectory,"/",datasets[h],".csv"), header=T)#
		N_tot_1 = N_tot_1 + dim(observations)[1]#
		observations = unique(observations[,c("longitude","latitude")])#
		N_tot_2 = N_tot_2 + dim(observations)[1]#
		observations = observations[!is.na(extract(rasters_1[[1]], observations)),]#
		observations = observations[!is.na(extract(rasters_2[[1]], observations)),]#
		observations_list[[h]] = observations; cat(datasets[h]); cat("\n")#
		if (h == 1)#
			{#
				xmin = min(observations[,1]); xmax = max(observations[,1])#
				ymin = min(observations[,2]); ymax = max(observations[,2])#
			}	else		{#
				if (xmin > min(observations[,1])) xmin = min(observations[,1])#
				if (xmax < max(observations[,1])) xmax = max(observations[,1])#
				if (ymin > min(observations[,2])) ymin = min(observations[,2])#
				if (ymax < max(observations[,2])) ymax = max(observations[,2])#
			}#
		hull = chull(observations); hull = c(hull,hull[1])#
		p = Polygon(observations[hull,]); ps = Polygons(list(p),1)#
		sps = SpatialPolygons(list(ps)); crs(sps) = crs(landPolygons_light)#
		range = intersect(sps, landPolygons_light); plot(range, add=T, col="green3")#
		index = which(species_information[,"species"]==datasets[h])#
		species_information[index,"area_km2"] = round(sum(areaPolygon(range)/1000000))#
	}#
write.csv(species_information, "species_information.csv", quote=F, row.names=F)
# system("R CMD javareconf"); # rJava_0.9-10.tar.gz doesn't work...#
# install.packages("rJava_0.9-9.tar.gz", repos=NULL, type="source")#
# install.packages("dismo_1.1-4.tar.gz", repos=NULL, type="source")#
#
dyn.load("/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/server/libjvm.dylib") # MacBook Simon#
# dyn.load("/Library/Java/JavaVirtualMachines/jdk1.8.0_102.jdk/Contents/Home/jre/lib/server/libjvm.dylib") # MacPro Simon#
library(raster); library(fields); library(RColorBrewer); library(dismo); library(rJava); library(gbm); library(geosphere); library(rgdal); library(pgirmess)#
options(java.parameters="-Xmx15000m"); source("decreaseResolution.r"); source("landCoverRasters.r")#
#
datasetsDirectory = "Bombus_observations_2"#
resolution = "16"; # resolution = "04"#
e_1 = extent(-19, 88, 19, 82); e_2 = extent(-15, 84, 23, 78)#
subsampling_adjacent_cells = TRUE; background_cell = TRUE#
background_mask = FALSE; human_pop_density_bias = FALSE#
cols = rev(colorRampPalette(brewer.pal(11,"RdYlBu"))(121)[11:101])#
plotWidth = 7.0; plotHeight = 6.2#
datasets = list.files(datasetsDirectory); # datasets = datasets[40]#
datasets = gsub(".csv","",datasets[which(grepl(".csv",datasets))])#
#
# 1.
system("R CMD javareconf"); # rJava_0.9-10.tar.gz doesn't work...
install.packages("rJava_0.9-9.tar.gz", repos=NULL, type="source")
dyn.load("/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/server/libjvm.dylib") # MacBook Simon#
# dyn.load("/Library/Java/JavaVirtualMachines/jdk1.8.0_102.jdk/Contents/Home/jre/lib/server/libjvm.dylib") # MacPro Simon#
library(raster); library(fields); library(RColorBrewer); library(dismo); library(rJava); library(gbm); library(geosphere); library(rgdal); library(pgirmess)#
options(java.parameters="-Xmx15000m"); source("decreaseResolution.r"); source("landCoverRasters.r")
library(raster); library(fields); library(RColorBrewer);
library(gbm); library(geosphere); library(rgdal); library(pgirmess)
install.packages("gbm")
library(gbm); library(geosphere); library(rgdal); library(pgirmess)
install.packages("pgirmess")
library(raster); library(fields); library(RColorBrewer); library(dismo); library(rJava); library(gbm); library(geosphere); library(rgdal); library(pgirmess)
install.packages("rJava_0.9-9.tar.gz", repos=NULL, type="source")
library(rJava)
install.packages("dismo_1.1-4.tar.gz", repos=NULL, type="source")
system("R CMD javareconf"); # rJava_0.9-10.tar.gz doesn't work...
install.packages("rJava_0.9-9.tar.gz", repos=NULL, type="source")
install.packages("dismo_1.1-4.tar.gz", repos=NULL, type="source")#
#
# dyn.load("/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/server/libjvm.dylib") # MacBook Simon
install.packages("rJava")
library(raster); library(fields); library(RColorBrewer); library(dismo); library(rJava); library(gbm); library(geosphere); library(rgdal); library(pgirmess)#
options(java.parameters="-Xmx15000m"); source("decreaseResolution.r"); source("landCoverRasters.r")
library(rJava)
system("R CMD javareconf"); # rJava_0.9-10.tar.gz doesn't work...
install.packages("rJava_0.9-9.tar.gz", repos=NULL, type="source")
library(raster); library(fields); library(RColorBrewer); library(dismo); library(rJava); library(gbm); library(geosphere); library(rgdal); library(pgirmess)
system("sudo R CMD javareconf"); # rJava_0.9-10.tar.gz didn't work before
# system("R CMD javareconf"); # rJava_0.9-10.tar.gz didn't work before
system("R CMD javareconf"); # rJava_0.9-10.tar.gz didn't work before
library(raster); library(fields); library(RColorBrewer); library(dismo); library(rJava); library(gbm); library(geosphere); library(rgdal); library(pgirmess)
dyn.load("/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/server/libjvm.dylib") # MacBook Simon
library(raster); library(fields); library(RColorBrewer); library(dismo); library(rJava); library(gbm); library(geosphere); library(rgdal); library(pgirmess)
dyn.load("/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/server/libjvm.dylib") # MacBook Simon
library(raster); library(fields); library(RColorBrewer); library(dismo); library(rJava); library(gbm); library(geosphere); library(rgdal); library(pgirmess)
dyn.load("/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/server/libjvm.dylib") # MacBook Simon
remove.packages("rJava")
install.packages("rJava_0.9-9.tar.gz", repos=NULL, type="source")
system("R CMD javareconf")
system("R CMD javareconf"); # rJava_0.9-10.tar.gz didn't work before
install.packages("rJava_0.9-9.tar.gz", repos=NULL, type="source")
install.packages("rJava")
dyn.load("/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/server/libjvm.dylib") # MacBook Simon
library(rJava)
dyn.load("/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/server/libjvm.dylib") # MacBook Simon
library(rJava)
install.packages("devtools")
library(devtools)
install_github("sdellicour/seraphim/macOS")
install_github("sdellicour/seraphim/unix_OS")
library(seraphim)
remove.packages("seraphim")
install.packages("devtools"); library(devtools)#
install_github("sdellicour/seraphim/unix_OS")#
library(seraphim)
logMLE1 = -12834.317605730235 # for RRW (logN)
logMLE2 = -12856.611381507528 # for DRW
logMLE3 = -12842.860284601575 # for DRW (latitude only)
BF12 = exp(logMLE1/logMLE2)
BF12
BF21 = exp(logMLE2/logMLE1)
BF21
exp(logMLE2)
exp(logMLE1)
exp(logMLE2)
logMLE1/logMLE2
BF12 = exp(logMLE1-logMLE2)
BF12
logMLE1-logMLE2
BF12 = logMLE1-logMLE2
BF12
?exp
e^3
2.71^(logMLE1-logMLE2)
exp(logMLE1-logMLE2)
exp(logMLE1)/exp(logMLE2)
exp(logMLE2)
exp(logMLE1)
lubridate
library(lubridate)
date_decimal(2020.18579234973)
date_decimal(2020.16393442623)
date_decimal(2020.17759562842)
date_decimal(2020.17486338798)
date_decimal(2020.18579234973)
date_decimal(2020.19945355191)
date_decimal(2020.19945355)
date_decimal(2020.20765027322)
date_decimal(2020.2650273224)
library(ape)
?ace
install.packages("plotly")
us_cities = read.csv("https://raw.githubusercontent.com/plotly/datasets/master/us-cities-top-1k.csv")
fig <- us_cities
fig <- fig %>%#
  plot_ly(#
    lat = ~lat,#
    lon = ~lon,#
    marker = list(color = "fuchsia"),#
    type = 'scattermapbox',#
    hovertext = us_cities[,"City"])
fig <- fig#
  plot_ly(#
    lat = ~lat,#
    lon = ~lon,#
    marker = list(color = "fuchsia"),#
    type = 'scattermapbox',#
    hovertext = us_cities[,"City"])
library(plotly)
fig <- fig %>%#
  plot_ly(#
    lat = ~lat,#
    lon = ~lon,#
    marker = list(color = "fuchsia"),#
    type = 'scattermapbox',#
    hovertext = us_cities[,"City"])
fig <- fig %>%#
  layout(#
    mapbox = list(#
      style = 'open-street-map',#
      zoom =2.5,#
      center = list(lon = -88, lat = 34)))
fig
library(diagram)#
library(lubridate)#
library(maptools)#
library(phylotate)#
library(seraphim)
dir.create(file.path("POWV_dispersal_statistics"), showWarnings=F)#
analysis = "BEAST_run_RRWj01"; localTreesDirectory = paste0(analysis,"_ext2"); nberOfExtractionFiles = 1000#
timeSlices = 100; onlyTipBranches = FALSE; showingPlots = FALSE; nberOfCores = 10; slidingWindow = 1#
outputName = paste0("Dispersal_statistics/",analysis)#
spreadStatistics(localTreesDirectory, nberOfExtractionFiles, timeSlices, onlyTipBranches, showingPlots, outputName, nberOfCores, slidingWindow)#
	# mean branch dispersal velocity of xx km/day (95% CI = [xx-xx])#
	# weighted branch dispersal velocity of xx km/day (95% CI = [xx-xx])#
	# mean diffusion coefficient of xx km/day (95% CI = [xx-xx])#
	# weighted branch dispersal velocity of xx km/day (95% CI = [xx-xx])
getwd()
install.packages("ape")
library(diagram)#
library(lubridate)#
library(seraphim)#
library(treeio)#
#
writingFiles = TRUE; showingPlots = TRUE#
writingFiles = FALSE; showingPlots = FALSE#
#
nberOfExtractionFiles = 900#
#
NYC_counties = c("NewYork","Bronx","Kings","Queens","Richmond","Nassau","Suffolk","Westchester")#
variants = c("Alpha","Beta","Delta","Epsilon","Eta","Gamma","Kappa","Lambda","Mu","O-BA1","O-BA2","O-BA3","Theta","Zeta")#
variants = c("Iota","Alpha","Delta","O-BA1")#
#
# 3. Analysing the number of distinct intropduction events (not performed)#
#
burnIns = rep(31, length(variants))
h=3
data = read.table(paste0("Preliminary_discrete_runs/",variants[h],"_DTA.txt"), head=T)
mostRecentSamplingDatum = max(decimal_date(ymd(data[,"collection_date"])), na.rm=T)
NYC_branches_list = rep(NA,length(trees)); NYC_introductions_list = rep(NA,length(trees))
i = burnIns[h]+1
tree2 = readAnnotatedNexus(paste0(variants[h],"_",i,".tree"))
NYC_branches = 0; NYC_introductions = 0; NYC_tipBranches = 0
NYC_tMRCAs = c(); clusters_of_one_sequence = 0
j=1
tree2$annotations[[j]]$location
NYC_branches = NYC_branches + 1
index = which(tree2$edge[,2]==tree2$edge[j,1])
tree2$annotations[[index]]$location
index = which(tree2$edge[,2]==tree2$edge[j,1])
index
NYC_branches = 0; NYC_introductions = 0; NYC_tipBranches = 0#
				NYC_tMRCAs = c(); clusters_of_one_sequence = 0#
				for (j in 1:dim(tree2$edge)[1])#
					{#
						if (tree2$annotations[[j]]$location == "NYC_counties")#
							{#
								NYC_branches = NYC_branches + 1#
								index = which(tree2$edge[,2]==tree2$edge[j,1])#
								if (tree2$annotations[[index]]$location != "NYC_counties")#
									{#
										NYC_introductions = NYC_introductions + 1#
										tMRCA = mostRecentSamplingDatum-nodeheight(tree2,tree2$edge[j,1])#
										NYC_tMRCAs = c(NYC_tMRCAs, tMRCA)#
										if (!tree2$edge[j,2]%in%tree2$edge[,1])#
											{#
												clusters_of_one_sequence = clusters_of_one_sequence + 1#
											}#
									}#
								if (!tree2$edge[j,2]%in%tree2$edge[,1])#
									{#
										NYC_tipBranches = NYC_tipBranches + 1#
									}#
							}#
					}
tree2$annotations[[j]]$location
j
dim(tree2$edge)[1]
j=j+1
tree2$annotations[[j]]$location
j=j-1
(!is.null(tree2$annotations[[j]]$location))&&(tree2$annotations[[j]]$location == "NYC_counties")
library(diagram)#
library(lubridate)#
library(seraphim)#
library(treeio)#
#
writingFiles = TRUE; showingPlots = TRUE#
writingFiles = FALSE; showingPlots = FALSE#
#
nberOfExtractionFiles = 900#
#
NYC_counties = c("NewYork","Bronx","Kings","Queens","Richmond","Nassau","Suffolk","Westchester")#
variants = c("Alpha","Beta","Delta","Epsilon","Eta","Gamma","Kappa","Lambda","Mu","O-BA1","O-BA2","O-BA3","Theta","Zeta")#
variants = c("Iota","Alpha","Delta","O-BA1")
??register
burnIns = rep(31, length(variants)); registerDoMC(cores=10)
buffer = foreach(i = (burnIns[h]+1):300)#
		# buffer = foreach(i = (burnIns[h]+1):length(indices2))#
		# # for (i in (burnIns[h]+1):length(indices2)) {#
				# tree1 = trees[c(indices1[1:(length(indices1)-1)],indices2[i],indices1[length(indices1)])]#
				# write(tree1, paste0(variants[h],"_",i,".tree"))#
				# tree2 = readAnnotatedNexus(paste0(variants[h],"_",i,".tree"))#
				# NYC_branches = 0; NYC_introductions = 0; NYC_tipBranches = 0#
				# NYC_tMRCAs = c(); clusters_of_one_sequence = 0#
				# for (j in 1:dim(tree2$edge)[1])#
					# {#
						# if ((!is.null(tree2$annotations[[j]]$location))&&(tree2$annotations[[j]]$location == "NYC_counties"))#
							# {#
								# NYC_branches = NYC_branches + 1#
								# index = which(tree2$edge[,2]==tree2$edge[j,1])#
								# if ((!is.null(tree2$annotations[[index]]$location))&&(tree2$annotations[[index]]$location != "NYC_counties"))#
									# {#
										# NYC_introductions = NYC_introductions + 1#
										# tMRCA = mostRecentSamplingDatum-nodeheight(tree2,tree2$edge[j,1])#
										# NYC_tMRCAs = c(NYC_tMRCAs, tMRCA)#
										# if (!tree2$edge[j,2]%in%tree2$edge[,1])#
											# {#
												# clusters_of_one_sequence = clusters_of_one_sequence + 1#
											# }#
									# }#
								# if (!tree2$edge[j,2]%in%tree2$edge[,1])#
									# {#
										# NYC_tipBranches = NYC_tipBranches + 1#
									# }#
							# }#
					# }#
				# file.remove(paste0(variants[h],"_",i,".tree"))#
				# cbind(NYC_tipBranches, NYC_introductions, clusters_of_one_sequence)#
				cbind(runif(1,1,10),runif(1,1,10),runif(1,1,10))#
			}
buffer = foreach(i = (burnIns[h]+1):300) {#
		# buffer = foreach(i = (burnIns[h]+1):length(indices2))#
		# # for (i in (burnIns[h]+1):length(indices2)) {#
				# tree1 = trees[c(indices1[1:(length(indices1)-1)],indices2[i],indices1[length(indices1)])]#
				# write(tree1, paste0(variants[h],"_",i,".tree"))#
				# tree2 = readAnnotatedNexus(paste0(variants[h],"_",i,".tree"))#
				# NYC_branches = 0; NYC_introductions = 0; NYC_tipBranches = 0#
				# NYC_tMRCAs = c(); clusters_of_one_sequence = 0#
				# for (j in 1:dim(tree2$edge)[1])#
					# {#
						# if ((!is.null(tree2$annotations[[j]]$location))&&(tree2$annotations[[j]]$location == "NYC_counties"))#
							# {#
								# NYC_branches = NYC_branches + 1#
								# index = which(tree2$edge[,2]==tree2$edge[j,1])#
								# if ((!is.null(tree2$annotations[[index]]$location))&&(tree2$annotations[[index]]$location != "NYC_counties"))#
									# {#
										# NYC_introductions = NYC_introductions + 1#
										# tMRCA = mostRecentSamplingDatum-nodeheight(tree2,tree2$edge[j,1])#
										# NYC_tMRCAs = c(NYC_tMRCAs, tMRCA)#
										# if (!tree2$edge[j,2]%in%tree2$edge[,1])#
											# {#
												# clusters_of_one_sequence = clusters_of_one_sequence + 1#
											# }#
									# }#
								# if (!tree2$edge[j,2]%in%tree2$edge[,1])#
									# {#
										# NYC_tipBranches = NYC_tipBranches + 1#
									# }#
							# }#
					# }#
				# file.remove(paste0(variants[h],"_",i,".tree"))#
				# cbind(NYC_tipBranches, NYC_introductions, clusters_of_one_sequence)#
				cbind(runif(1,1,10),runif(1,1,10),runif(1,1,10))#
			}
buffer = foreach(i = (burnIns[h]+1):300) %dopar% {#
		# buffer = foreach(i = (burnIns[h]+1):length(indices2)) %dopar% {#
		# # for (i in (burnIns[h]+1):length(indices2)) {#
				# tree1 = trees[c(indices1[1:(length(indices1)-1)],indices2[i],indices1[length(indices1)])]#
				# write(tree1, paste0(variants[h],"_",i,".tree"))#
				# tree2 = readAnnotatedNexus(paste0(variants[h],"_",i,".tree"))#
				# NYC_branches = 0; NYC_introductions = 0; NYC_tipBranches = 0#
				# NYC_tMRCAs = c(); clusters_of_one_sequence = 0#
				# for (j in 1:dim(tree2$edge)[1])#
					# {#
						# if ((!is.null(tree2$annotations[[j]]$location))&&(tree2$annotations[[j]]$location == "NYC_counties"))#
							# {#
								# NYC_branches = NYC_branches + 1#
								# index = which(tree2$edge[,2]==tree2$edge[j,1])#
								# if ((!is.null(tree2$annotations[[index]]$location))&&(tree2$annotations[[index]]$location != "NYC_counties"))#
									# {#
										# NYC_introductions = NYC_introductions + 1#
										# tMRCA = mostRecentSamplingDatum-nodeheight(tree2,tree2$edge[j,1])#
										# NYC_tMRCAs = c(NYC_tMRCAs, tMRCA)#
										# if (!tree2$edge[j,2]%in%tree2$edge[,1])#
											# {#
												# clusters_of_one_sequence = clusters_of_one_sequence + 1#
											# }#
									# }#
								# if (!tree2$edge[j,2]%in%tree2$edge[,1])#
									# {#
										# NYC_tipBranches = NYC_tipBranches + 1#
									# }#
							# }#
					# }#
				# file.remove(paste0(variants[h],"_",i,".tree"))#
				# cbind(NYC_tipBranches, NYC_introductions, clusters_of_one_sequence)#
				cbind(runif(1,1,10),runif(1,1,10),runif(1,1,10))#
			}
h=3
buffer = foreach(i = (burnIns[h]+1):300) %dopar% {#
		# buffer = foreach(i = (burnIns[h]+1):length(indices2)) %dopar% {#
		# # for (i in (burnIns[h]+1):length(indices2)) {#
				# tree1 = trees[c(indices1[1:(length(indices1)-1)],indices2[i],indices1[length(indices1)])]#
				# write(tree1, paste0(variants[h],"_",i,".tree"))#
				# tree2 = readAnnotatedNexus(paste0(variants[h],"_",i,".tree"))#
				# NYC_branches = 0; NYC_introductions = 0; NYC_tipBranches = 0#
				# NYC_tMRCAs = c(); clusters_of_one_sequence = 0#
				# for (j in 1:dim(tree2$edge)[1])#
					# {#
						# if ((!is.null(tree2$annotations[[j]]$location))&&(tree2$annotations[[j]]$location == "NYC_counties"))#
							# {#
								# NYC_branches = NYC_branches + 1#
								# index = which(tree2$edge[,2]==tree2$edge[j,1])#
								# if ((!is.null(tree2$annotations[[index]]$location))&&(tree2$annotations[[index]]$location != "NYC_counties"))#
									# {#
										# NYC_introductions = NYC_introductions + 1#
										# tMRCA = mostRecentSamplingDatum-nodeheight(tree2,tree2$edge[j,1])#
										# NYC_tMRCAs = c(NYC_tMRCAs, tMRCA)#
										# if (!tree2$edge[j,2]%in%tree2$edge[,1])#
											# {#
												# clusters_of_one_sequence = clusters_of_one_sequence + 1#
											# }#
									# }#
								# if (!tree2$edge[j,2]%in%tree2$edge[,1])#
									# {#
										# NYC_tipBranches = NYC_tipBranches + 1#
									# }#
							# }#
					# }#
				# file.remove(paste0(variants[h],"_",i,".tree"))#
				# cbind(NYC_tipBranches, NYC_introductions, clusters_of_one_sequence)#
				cbind(runif(1,1,10),runif(1,1,10),runif(1,1,10))#
			}
buffer = foreach(i = (burnIns[h]+1):10000) %dopar% {#
		# buffer = foreach(i = (burnIns[h]+1):length(indices2)) %dopar% {#
		# # for (i in (burnIns[h]+1):length(indices2)) {#
				# tree1 = trees[c(indices1[1:(length(indices1)-1)],indices2[i],indices1[length(indices1)])]#
				# write(tree1, paste0(variants[h],"_",i,".tree"))#
				# tree2 = readAnnotatedNexus(paste0(variants[h],"_",i,".tree"))#
				# NYC_branches = 0; NYC_introductions = 0; NYC_tipBranches = 0#
				# NYC_tMRCAs = c(); clusters_of_one_sequence = 0#
				# for (j in 1:dim(tree2$edge)[1])#
					# {#
						# if ((!is.null(tree2$annotations[[j]]$location))&&(tree2$annotations[[j]]$location == "NYC_counties"))#
							# {#
								# NYC_branches = NYC_branches + 1#
								# index = which(tree2$edge[,2]==tree2$edge[j,1])#
								# if ((!is.null(tree2$annotations[[index]]$location))&&(tree2$annotations[[index]]$location != "NYC_counties"))#
									# {#
										# NYC_introductions = NYC_introductions + 1#
										# tMRCA = mostRecentSamplingDatum-nodeheight(tree2,tree2$edge[j,1])#
										# NYC_tMRCAs = c(NYC_tMRCAs, tMRCA)#
										# if (!tree2$edge[j,2]%in%tree2$edge[,1])#
											# {#
												# clusters_of_one_sequence = clusters_of_one_sequence + 1#
											# }#
									# }#
								# if (!tree2$edge[j,2]%in%tree2$edge[,1])#
									# {#
										# NYC_tipBranches = NYC_tipBranches + 1#
									# }#
							# }#
					# }#
				# file.remove(paste0(variants[h],"_",i,".tree"))#
				# cbind(NYC_tipBranches, NYC_introductions, clusters_of_one_sequence)#
				cbind(runif(1,1,10),runif(1,1,10),runif(1,1,10))#
			}
length(buffer)
NYC_tipBranches = buffer[[length(buffer)]][1]
NYC_tipBranches
buffer[[length(buffer)]]
NYC_introductions_list = rep(NA,length(trees)); clusters_of_one_sequence_list = rep(NA,length(trees))#
buffer = foreach(i = (burnIns[h]+1):10000) %dopar% {#
		# buffer = foreach(i = (burnIns[h]+1):length(indices2)) %dopar% {#
		# # for (i in (burnIns[h]+1):length(indices2)) {#
				# tree1 = trees[c(indices1[1:(length(indices1)-1)],indices2[i],indices1[length(indices1)])]#
				# write(tree1, paste0(variants[h],"_",i,".tree"))#
				# tree2 = readAnnotatedNexus(paste0(variants[h],"_",i,".tree"))#
				# NYC_branches = 0; NYC_introductions = 0; NYC_tipBranches = 0#
				# NYC_tMRCAs = c(); clusters_of_one_sequence = 0#
				# for (j in 1:dim(tree2$edge)[1])#
					# {#
						# if ((!is.null(tree2$annotations[[j]]$location))&&(tree2$annotations[[j]]$location == "NYC_counties"))#
							# {#
								# NYC_branches = NYC_branches + 1#
								# index = which(tree2$edge[,2]==tree2$edge[j,1])#
								# if ((!is.null(tree2$annotations[[index]]$location))&&(tree2$annotations[[index]]$location != "NYC_counties"))#
									# {#
										# NYC_introductions = NYC_introductions + 1#
										# tMRCA = mostRecentSamplingDatum-nodeheight(tree2,tree2$edge[j,1])#
										# NYC_tMRCAs = c(NYC_tMRCAs, tMRCA)#
										# if (!tree2$edge[j,2]%in%tree2$edge[,1])#
											# {#
												# clusters_of_one_sequence = clusters_of_one_sequence + 1#
											# }#
									# }#
								# if (!tree2$edge[j,2]%in%tree2$edge[,1])#
									# {#
										# NYC_tipBranches = NYC_tipBranches + 1#
									# }#
							# }#
					# }#
				# file.remove(paste0(variants[h],"_",i,".tree"))#
				# cbind(NYC_tipBranches, NYC_introductions, clusters_of_one_sequence)#
				cbind(runif(1,1,10),runif(1,1,10),runif(1,1,10))#
			}#
		NYC_tipBranches = buffer[[length(buffer)]][1]#
		for (i in (burnIns[h]+1):length(indices2))#
			{#
				NYC_introductions_list[[i]] = buffer[[i]][2]#
				clusters_of_one_sequence_list[[i]] = buffer[[i]][3]#
			}#
		quantiles = quantile(NYC_introductions_list[!is.na(NYC_introductions_list)],probs=c(0.025,0.975))#
		cat("A minimum number of ",median(NYC_introductions_list[!is.na(NYC_introductions_list)])," lineage introductions (95% HPD interval = [",#
			quantiles[1],"-",quantiles[2],"])"," identified from the global phylogenetic analysis of ",NYC_tipBranches," ",variants[h]," sequences sampled in the NYC area",sep="")#
		proportions_of_cluster_1 = clusters_of_one_sequence_list/NYC_introductions_list#
		quantiles = quantile(proportions_of_cluster_1[!is.na(proportions_of_cluster_1)],probs=c(0.025,0.975))#
		cat("Proportion of clusters of n = 1: ",median(proportions_of_cluster_1[!is.na(proportions_of_cluster_1)])," (95% HPD interval = [",quantiles[1],"-",quantiles[2],"])")
NYC_introductions_list = rep(NA,length(trees)); clusters_of_one_sequence_list = rep(NA,length(trees))#
buffer = foreach(i = (burnIns[h]+1):10000) %dopar% {#
		# buffer = foreach(i = (burnIns[h]+1):length(indices2)) %dopar% {#
		# # for (i in (burnIns[h]+1):length(indices2)) {#
				# tree1 = trees[c(indices1[1:(length(indices1)-1)],indices2[i],indices1[length(indices1)])]#
				# write(tree1, paste0(variants[h],"_",i,".tree"))#
				# tree2 = readAnnotatedNexus(paste0(variants[h],"_",i,".tree"))#
				# NYC_branches = 0; NYC_introductions = 0; NYC_tipBranches = 0#
				# NYC_tMRCAs = c(); clusters_of_one_sequence = 0#
				# for (j in 1:dim(tree2$edge)[1])#
					# {#
						# if ((!is.null(tree2$annotations[[j]]$location))&&(tree2$annotations[[j]]$location == "NYC_counties"))#
							# {#
								# NYC_branches = NYC_branches + 1#
								# index = which(tree2$edge[,2]==tree2$edge[j,1])#
								# if ((!is.null(tree2$annotations[[index]]$location))&&(tree2$annotations[[index]]$location != "NYC_counties"))#
									# {#
										# NYC_introductions = NYC_introductions + 1#
										# tMRCA = mostRecentSamplingDatum-nodeheight(tree2,tree2$edge[j,1])#
										# NYC_tMRCAs = c(NYC_tMRCAs, tMRCA)#
										# if (!tree2$edge[j,2]%in%tree2$edge[,1])#
											# {#
												# clusters_of_one_sequence = clusters_of_one_sequence + 1#
											# }#
									# }#
								# if (!tree2$edge[j,2]%in%tree2$edge[,1])#
									# {#
										# NYC_tipBranches = NYC_tipBranches + 1#
									# }#
							# }#
					# }#
				# file.remove(paste0(variants[h],"_",i,".tree"))#
				# cbind(NYC_tipBranches, NYC_introductions, clusters_of_one_sequence)#
				cbind(runif(1,1,10),runif(1,1,10),runif(1,1,10))#
			}#
		NYC_tipBranches = buffer[[length(buffer)]][1]#
		for (i in (burnIns[h]+1):length(buffer))#
			{#
				NYC_introductions_list[[i]] = buffer[[i]][2]#
				clusters_of_one_sequence_list[[i]] = buffer[[i]][3]#
			}#
		quantiles = quantile(NYC_introductions_list[!is.na(NYC_introductions_list)],probs=c(0.025,0.975))#
		cat("A minimum number of ",median(NYC_introductions_list[!is.na(NYC_introductions_list)])," lineage introductions (95% HPD interval = [",#
			quantiles[1],"-",quantiles[2],"])"," identified from the global phylogenetic analysis of ",NYC_tipBranches," ",variants[h]," sequences sampled in the NYC area",sep="")#
		proportions_of_cluster_1 = clusters_of_one_sequence_list/NYC_introductions_list#
		quantiles = quantile(proportions_of_cluster_1[!is.na(proportions_of_cluster_1)],probs=c(0.025,0.975))#
		cat("Proportion of clusters of n = 1: ",median(proportions_of_cluster_1[!is.na(proportions_of_cluster_1)])," (95% HPD interval = [",quantiles[1],"-",quantiles[2],"])")
# To do list and/or issues to deal with:#
	# - IQ-TREE+TreeTime analysis for BA.1 still running (current output with HKY+F+R2 model)#
	# - IQ-TREE+TreeTime analysis for Delta still running (current output with HKY+F+R2 model)#
	# - performing some analyses with Thorney BEAST for Alpha, Iota, Delta, Omicron (Verity)#
	# - n.b.: current results and figures are based on TreeTime trees (and only 750 posterior#
	#	trees in the case of the BSSVS analysis conducted for Iota) --> to be updated (Thorney)#
	# - computing the number of distinct introduction events as well as the number of events#
	#	that only led to the detection of a single sample (+ 95% HPD intervals in both cases)#
	# - plotting the distribution of TMRCA (small vertical bars added to the scales in Figure 2)#
	# - generating a graph displaying the inferred locations of the MRCA of each clade (+HPD)#
#
# Ideas of invasion/dispersal metrics to compare the different variants:#
	# - comparison of the growth rate advantage (that will be computed by Sam + graphs)#
	# - evolution of the ratio between the number of circulating clusters and lineages (branches)#
	# - evolution of the averaged proportion of circulating lineages belonging to the same cluster#
	# - potential idea: something based on the Shannon entropy used in the two waves study ??#
	# - evolution of the averaged duration since the cluster introduction event (cluster TMRCA)#
	# - averaged ratio between the number of county transition events and the cluster size#
	# - average number of counties infected by a distinct introduction event (distinct cluster)#
	# - averaged proportion of phylogeny branches associated with a transition event between counties#
	# - dispersal statistics: weighted lineage dispersal velocity and weighted diffusion coefficient#
#
library(diagram)#
library(lubridate)#
library(seraphim)#
library(treeio)#
#
writingFiles = TRUE; showingPlots = TRUE#
writingFiles = FALSE; showingPlots = FALSE#
#
nberOfExtractionFiles = 900#
#
NYC_counties = c("NewYork","Bronx","Kings","Queens","Richmond","Nassau","Suffolk","Westchester")#
variants = c("Alpha","Beta","Delta","Epsilon","Eta","Gamma","Kappa","Lambda","Mu","O-BA1","O-BA2","O-BA3","Theta","Zeta")#
variants = c("Iota","Alpha","Delta","O-BA1")
wd = getwd()
length(variants)
variants
h=2
setwd(paste0(wd,"/DTA_boroughs_analyses/",variants[h],"_DTA/"))#
		treeFiles = list.files(); treeFiles = gsub(".trees","",treeFiles[which(grepl(".trees",treeFiles))])#
		for (j in 1:length(treeFiles))#
			{#
				system(paste0("BEAST_1104/bin/treeannotator -burninTrees 101 -heights keep ",treeFiles[j],".trees ",treeFiles[j],".tree"), ignore.stdout=F, ignore.stderr=F)#
			}
setwd(wd)
source("DTA_tree_extractions.r")#
source("MCC_tree_extractions.r")#
wd = getwd(); previousVersion = F
clusters1_list = readRDS("Step5_Clusters1_list.rds"); clusters2_list = readRDS("Step5_Clusters2_list.rds")
h
clusters2 = clusters2_list[[h]]#
		setwd(paste0(wd,"/DTA_boroughs_analyses/",variants[h],"_DTA/"))#
		treeFiles = list.files(); treeFiles = treeFiles[which(grepl(".trees",treeFiles))]
for (i in 1:length(treeFiles))#
			{#
				dir.create(file.path(gsub(".trees","_ext",treeFiles[i])), showWarnings=F)#
				trees = readAnnotatedNexus(treeFiles[i]); trees = trees[102:1001]#
				for (j in 1:length(trees))#
					{#
						tree = trees[[j]]#
						if (previousVersion)#
							{#
								tab = matrix(nrow=dim(tree$edge)[1], ncol=4)#
								colnames(tab) = c("node1","node2","startLoc","endLoc")#
								tab[,"node1"] = tree$edge[,1]; tab[,"node2"] = tree$edge[,2]#
								for (k in 1:dim(tree$edge)[1])#
									{#
										tab[k,"endLoc"] = tree$annotations[[k]]$location#
										index = which(tree$edge[,2]==tree$edge[k,1])#
										if (length(index) == 1)#
											{#
												tab[k,"startLoc"] = tree$annotations[[index]]$location#
											}	else		{#
												if (!tree$edge[k,1]%in%tree$edge[,2])#
													{#
														tab[k,"startLoc"] = tree$root.annotation$location#
													}#
											}#
									}#
							}	else	{#
								index = as.numeric(unlist(strsplit(gsub(".trees","",treeFiles[i]),"_"))[2])#
								mostRecentSamplingDatum = max(as.numeric(clusters2[[index]][which(!is.na(clusters2[[index]][,"location"])),"collection_date"]))#
								tab = DTA_tree_extractions(tree, mostRecentSamplingDatum)#
								tab$cladeID = rep(index, dim(tab)[1])#
							}#
						write.csv(tab, paste0(gsub(".trees","_ext",treeFiles[i]),"/TreeExtractions_",j,".csv"), row.names=F, quote=F)#
					}#
			}#
		dir.create(file.path("All_clades_ext"), showWarnings=F); tab = NULL#
		for (i in 1:nberOfExtractionFiles)#
			{#
				for (j in 1:length(treeFiles))#
					{#
						if (j == 1)#
							{#
								tab = read.csv(paste0(gsub(".trees","_ext",treeFiles[j]),"/TreeExtractions_",i,".csv"))#
							}	else	{#
								tab = rbind(tab, read.csv(paste0(gsub(".trees","_ext",treeFiles[j]),"/TreeExtractions_",i,".csv")))#
							}#
					}#
				write.csv(tab, paste0("All_clades_ext/TreeExtractions_",i,".csv"), row.names=F, quote=F)#
			}#
		matrices = list()#
		for (i in 1:nberOfExtractionFiles)#
			{#
				mat = matrix(0, nrow=length(NYC_counties), ncol=length(NYC_counties))#
				row.names(mat) = NYC_counties; colnames(mat) = NYC_counties#
				tab = read.csv(paste0("All_clades_ext/TreeExtractions_",i,".csv"), head=T)#
				for (j in 1:dim(tab)[1])#
					{#
						index1 = which(NYC_counties==tab[j,"startLoc"])#
						index2 = which(NYC_counties==tab[j,"endLoc"])#
						mat[index1,index2] = mat[index1,index2]+1#
					}#
				matrices[[i]] = mat#
			}#
		saveRDS(matrices, "Matrices.rds")#
		log1 = scan(paste0("All_clades1.log"), what="", sep="\n", quiet=T, blank.lines.skip=F)#
		write(log1[which(!grepl("# ",log1))], paste0("All_clades3.log"))#
		log1 = read.table(paste0("All_clades3.log"), header=T, sep="\t"); log1 = log1[102:1001,]#
		setwd(paste0(wd,"/DTA_boroughs_analyses/",variants[h],"_TSW/"))#
		log2 = scan(paste0("All_clades1.log"), what="", sep="\n", quiet=T, blank.lines.skip=F)#
		write(log2[which(!grepl("# ",log2))], paste0("All_clades3.log"))#
		log2 = read.table(paste0("All_clades3.log"), header=T, sep="\t"); log2 = log2[102:1001,]#
		BFs1 = matrix(nrow=length(NYC_counties), ncol=length(NYC_counties))#
		BFs2 = matrix(nrow=length(NYC_counties), ncol=length(NYC_counties))#
		row.names(BFs1) = NYC_counties; colnames(BFs1) = NYC_counties#
		row.names(BFs2) = NYC_counties; colnames(BFs2) = NYC_counties#
		for (i in 1:length(NYC_counties))#
			{#
				for (j in 1:length(NYC_counties))#
					{#
						if (i != j)#
							{#
								colName = paste0("location.indicators.",gsub(" ",".",NYC_counties[i]),".",gsub(" ",".",NYC_counties[j]))#
								index1 = which(colnames(log1)==colName); index2 = which(colnames(log2)==colName)#
								p = sum(log1[,index1]==1)/dim(log1)[1]#
								K = 56 # length(locations)*(length(locations)-1) # K shoulf be divided by 2 if "symetric" case#
								q = (log(2)+K-1)/(K*(K-1))#
								BFs1[i,j] = (p/(1-p))/(q/(1-q))#
								p1 = sum(log1[,index1]==1)/dim(log1)[1]#
								p2 = sum(log2[,index2]==1)/dim(log2)[1]#
								BFs2[i,j] = (p1/(1-p1))/(p2/(1-p2))#
							}#
					}#
			}#
		setwd(paste0(wd,"/DTA_boroughs_analyses/",variants[h],"_DTA/"))#
		write.table(round(BFs1,1), paste0("BF_values.csv"), sep=",", quote=F)#
		setwd(paste0(wd,"/DTA_boroughs_analyses/",variants[h],"_TSW/"))#
		write.table(round(BFs2,1), paste0("BF_values.csv"), sep=",", quote=F)
